# 🔮오늘 공부한 내용

## 새로 배우게 된 내용
### list
- **여러 개의 값을 순서대로 저장**하는, **변경 가능한(mutable)** 시퀀스 자료형
- 모든 종류 데이터 담을 수 있음

### tuple
- 여러 개의 값을 순서대로 저장하는 **변경 불가능한** 시퀀스 자료형
- 단일 요소 튜플 만들 때 *반드시 Trailing comma(후행 쉼표) 사용*
```python
    my_tuple_2 = (1,)
    my_tuple_4 = 1, 'hello', 3.14, True
```

### range
- 실제로 모든 숫자 메모리에 저장하는 대신 시작값, 끝값, 간격이라는 '규칙'만 기억 -> 메모리 효율적으로 사용

### dict
- **key-value 쌍**으로 이루어진 **순서와 중복이 없는** **변경 가능한** 자료형
- { } 안에 쉼표로 구분
- key : value = 1 : 1 . but value에 콜렉션 올 수 있음. (모든 자료형 가능)
- key는 같은 위치(항렬?)에서만 중복 아니면 됨. like 함수에서 x가 2개이면 안되듯이!


### set
- **순서와 중복이 없는** **변경 가능한** 자료형
- { } 안에 쉼표로 구분 -> dict와 형식 같음
- 집합과 동일 연산 가능
```python
    my_set_1 = {1, 2, 3}
    my_set_2 = {3, 6, 9}
    #합집합
    print(my_set_1 | my_set_2) # {1, 2, 3, 6, 9}
    #차집합
    print(my_set_1 - my_set_2) # {1, 2}
    #교집합
    print(my_set_1 & my_set_2) # {3}
```
- 중복 허용 X, 순서 X
- 비어있는 딕셔너리와의 혼동 피하기 위해, 비어있는 세트는 set() 함수 생성

### collection
- 여러 개의 값을 하나로 묶어 관리하는 자료형들을 통칭하는 말

    |컬렉션명|변경 가능 여부|순서 존재 여부|
    |:---:|:---:|:---:|
    |str|X|O|
    |list|O|O|
    |tuple|X|O|
    |dict|O|X|
    |set|O|X|

### 비교 연산자 : is vs ==
- is는 '정체성'을, ==는 '가치'를 비교
- 두 연산자는 "같다"를 확인하는 목적이 근본적으로 다름
  - is는 '정체성(identity)'(메모리주소)이 같은지 확인
  - ==는 '값(value)'이 같은지 확인
- is 연산자는 싱글턴 객체 비교할 때 사용
  - 싱글턴 객체 : 파이썬 전체에서 단 하나의 객체만 생성되어 재사용되는 특별한 객체, 항상 같은 메모리 주소
  - ex. None, True, False

### 단축 평가
- and 연산자
  - 하나라도 '거짓'이면 바로 '거짓'
  - and는 연산을 -> 으로 진행, **처음 만나는 '거짓' 값 바로 반환**
  - 끝까지 갔는데 모든 값이 '참'이면, **맨 마지막 '참' 값을 반환**
- or 연산자
  - 하나라도 '참'이면 바로 '참'
  - or는 연산을 -> 으로 진행, **처음 만나는 '참' 값 바로 반환**
  - 끝까지 갔는데 모든 값이 '거짓'이면, **맨 마지막 '거짓' 값을 반환**

### 멤버십 연산자
- 특정 값이 시퀀스나 다른 컬렉션 안에 포함되어 있는지 확인하는 연산자
  |기호|내용|
  |:--:|:--|
  |in|왼쪽 피연산자가 오른쪽 피연산자의 시퀀스에 속하는지 확인|
  |not in|왼쪽 피연산자가 오른쪽 피연산자의 시퀀스에 속하지 않는지 확인|

### 연산자 우선순위
`( )`(grouping) > `[ ]`(인덱싱, 슬라이싱) > `**` > `+, -`(양,음수) > `*, /, //, %` > `+, -` > `<, <=, >, >=, ==, !=` > `is, is not` > `in, not in` > `not` > `and` > `or`

### trailing comma (후행 쉼표)
- 컬렉션의 마지막 요소 뒤에 붙는 쉼표
- 일반적으로 Trailing Comma 작성은 선택사항
- 장점
  - 가독성 향상 (dict에서 많이 사용)
    - 각 줄이 동일한 패턴 가짐
    - 코드 리뷰 용이
  - 유지보수 용이성
    - 항목 추가/제거가 간단
    - 실수로 인한 구문 오류 방지

### 얕은 복사 vs 깊은 복사
- 얕은 복사
  - copy()함수는 얕은 복사 
    ```python
        catalog = [[1,2],[3,4]]
        backup = catalog.copy()
        catalog[0][1] = 6
    ```
    ![얕은복사예시](../../TIL/img/얕은복사.png)
- 깊은 복사
  - deepcopy 이용
    ```python
        import copy
        a = [[1,2],[3,4]]
        b = copy.deepcopy(a)
    ```
  - slicing 사용
    ```python
        a = [[1,2],[3,4]]
        b = [arr[:] for arr in a]
    ```

## 헷갈렸던 점
- 논리 연산자에서 당연히 True/False를 값으로 낸다고 생각했는데, '참' 또는 '거짓'이 되는 값을 그대로 출력하는 것이었다.
- copy()함수가 1차원에서만 얕은 복사인지, 2차원에서도 얕은 복사인지 헷갈렸는데, `catalog[3][0] = [...]` 으로 했을 때 값이 모두 변했기 때문에 모두 얕은 복사임을 알게 되었다.

# 🔮공부하면서 어려웠던 점
### Q1. 과제) 2987. 복잡한 자료구조 lv3
- 요구사항에서 '주어진 data 변수에 할당된 값에서 적절한 값을 찾아 새로운 데이터를 생성한다.'라는 말이 새로운 변수를 설정하는 것이라고 착각했다.
- 계속 [ ] 안에 str을 입력할 수 없다는 에러 문구가 떴다.

### Q2. 과제) 1677. 깊은 복사와 indexing 접근 lv5
- catalog를 backup_catalog에 할당하고 catalog의 list 값을 바꿨더니 backup의 list 값도 함께 바뀌었다.
- 일반 copy() 함수를 사용했으나, `backup_catalog is catalog`의 값이 True로 나왔다.
- 슬라이싱으로 깊은 복사를 시도했으나, 아직 배우지 않은 for 문법이 쓰임을 발견하였다.

# 🔮어려움을 해결한 방법
### A1. 코드 하나씩 뜯어보기
- 다르게 접근하여 first_data 딕셔너리에 바로 data 딕셔너리 값을 넣는 방법을 택했다.
- 코드에서 data가 딕셔너리이기 이전에 리스트였다. 리스트인 부분은 [index]를, 딕셔너리인 부분은 [key]를 입력하였다.
- 중첩 dict일 때 즉, key와 연결된 value가 다시 key의 역할을 할 때, 어떤 데이터 타입인지 찬찬히 확인 필수

### A2. 구글링
- backup_catalog에 catalog를 할당한 것은 얕은 복사였다. 그래서 깊은 복사의 정의와 코드를 구글링하였다.
- copy() 함수 역시 얕은 복사였기 때문에 오류가 발생한 것을 알게 되었다.
- 깊은 복사를 하는 법에는 2가지가 있는데, 1) copy모듈 사용, 2) 슬라이싱 사용이었다.
- 예문의 column이 많지 않았기 때문에 for문을 풀어서 일일히 작성하였다.
> 짝꿍은 copy()함수를 사용하고, 값 변환을 `catalog[3] = [...]`으로 했을 때 새로운 list값이 생성되어 정상적으로 작동했다.
>
> 왜 이런 결과가 나오는 걸까?

# 🔮잘한 점
- 코드가 계속 오류가 발생할 때 바로 질문하거나 구글링 하지 않고 찬찬히 코드를 뜯어보며 스스로 생각했다.
- 이틀째 TIL을 작성하고 있다!

# 🔮아쉬웠던 점 / 궁금한 / 부족한 내용
- 깊은 복사에 대해 더 자세히 조사해야겠다.

# 🔮느낀점

## 다짐
- 주말에 코드 작성을 많이 시도해서 생각 안하고도 나올 수 있도록 연습하자.

## 오늘의 한줄 평가
- 나름 많은 지식을 정리했다.